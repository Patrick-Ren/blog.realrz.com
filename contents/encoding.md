---
title: Encoding
date: "2021-02-26"
language: zh-CN
category: other
---

> 在终端打印中文出现乱码是什么原因? Emoji 的网络传输效率和普通文本不相上下？为什么 Microsoft Yahei 的字体文件远比 Helvetica 的要大的多? 看完这篇博客，获得所有答案！

#### /[01]\*/ + Encoding = Information

在计算机中数据的最终存储形式都是一串 0 和 1, 用正则来表示就是 `/[01]*/`，这种排列组合简单却强大，可以表示任意大小的数据量。

但这还不够，毕竟排列组合只是一种数学概念，没有实际意义。给出一串 0 和 1, 我们需要一种解释(interpret)这串数据的规则才能获取到其中的信息, 这套规则被称为编码(encoding)。间言之，`/[01]*/ + encoding = Information`

一点历史: 上世纪 60 年代还没有计算机科学这门学科，电子工程系和数学系在争论谁应该去开创这片蓝海。最后电子工程系赢了，因为计算机科学不仅仅是数学还是工程(engineering)。编码(encoding) 就是一种工程: 没有绝对的对与错，只有设计的合不合理。

#### Encoding matters

如何对图片进行编码呢? 图片是由像素组成的，假设只需要表示红黄蓝绿这 4 种颜色，以下是 2 种编码方式:

```console
编码方式 A: 红: 00, 黄: 01, 蓝: 10, 绿: 11
编码方式 B: 红: 11, 黄: 10, 蓝: 01, 绿: 00
```

两种设计都非常合理，采用了 2 个比特来表示一种颜色，因为需要一共表示 4 种颜色，每一个比特都没有浪费。

现在我们要开发一个简单的像素预览程序, 它要能够查看用 A 或 B 进行编码的像素图片。

我们规定这种像素图片的格式: 第一个比特是 0 或 1 (0 代表采用 A 编码，1 代表采用 B 编码), 剩余比特是具体的像素信息

如果某个像素图片的二进制表示是 `01101` 那么它就会被程序渲染为 `绿黄` 这 2 个像素; 如果二进制序列是 `11101` 那么渲染的结果就是 `红蓝` 这 2 个像素。

上面的 2 个例子虽然实际像素的二进制序列都是 `1101`, 由于采用了不同的编码，结果解析出的颜色信息完全不同!

#### Character Encoding

有了 Encoding 的概念，计算机科学家们就开始对各种形式的信息进行编码，比如图片视频等。由于文本是信息的基本承载形式，人们自然最先考虑如何对文本进行编码。文本是由字符组成的，为文本制定编码等同于对字符集进行编码。

有趣的是字符存在多个编码标准，你可能听说过 ASCII, Unicode, UTF-8 等名词，下文将依次介绍它们。

#### ASCII - Latin Characters Only!

ASCII 码是比较早的一种字符编码, 全称是 Amercian Standard Code for Information Interchange。由于这种编码设计的比较早，当时计算机还没除美国以外的地方流行，所以 ASCII 码只考虑了英文用户, 只包含了一些常见的拉丁字符，这包括:

1. 33 个控制字符 (tab, carriage return, line feed...)
2. 空格 (space)
3. 大小写英文字符一共 52 个 ([a-zA-Z])
4. 10 个阿拉伯数字 ([0-9])
5. 32 个常用拉丁符号 (大部分是英文标点符号)

33 + 1 + 52 + 10 + 32 = 128, ASCII 表示的字符集一共有 128 个字符

[这里](https://www.rapidtables.com/code/text/ascii-table.html) 是一张完整的 ASCII 表

请注意，ASCII 表中前 32 个最后 1 个字符(DEL)属于控制字符所以是不可打印的(non-printable)， 中间 95 个字符是可打印的(printable)。这 33 个控制字符大部分都已经过时了，只有 tab, carriage return, line feed 等少数还被我们使用着。

ASCII 使用一个字节表示一个字符, 一个字节有 8 比特，而 ASCII 只需包含 128 个字符，因此也就只使用了 7 个比特(2^7=128)。

当时内存那么紧张，为什么还要多占用一个比特？主要有 2 个原因，第一比特是个比较“整”的单位，这就像小时候我们给大人买瓶酱油，酱油 9 块钱，父母一般会给一张 10 元纸币。第二是为了以后的扩展考虑，万一以后要加什么字符，就可以利用剩下的那个比特了。实际上，人们确实有利用多出来这个比特，利用了这个比特的 ASCII 叫 Extended ASCII, 不过这不是本文的讨论重点了。

#### Unicode - One Standard For All Languages

ASCII 只能为英文用户服务，后来使用其他语言的人们也开始使用计算机，非英语国家就开始为自己使用的语言制定编码标准。你可能听说过 GB 18030, 这是中国政府制定的中文编码规范，支持简体和繁体中文。这样只要计算机上装有 GB 18030 就可以显示和输入中文了。日本也有自己的标准，韩国也有自己的标准，中东也有自己的标准...

问题开始出现，难道要为每种语言都制定一个标准吗? 想象一下，你给一个美国朋友发了封邮件，里面有中文而且用的是 GB 18030 编码，由于他不大可能在电脑上装 GB 18030，这时候邮件该如何显示就成了问题。

如果我们可以制定一种编码标准，里面包含了各种语言的字符，所有人都用这个标准的话，那国际间交流就可以很顺畅了。这就是 Unicode 诞生的背景。

Unicode 规定了字符对应的数值，也叫 Code Point, 由于直接用二进制表示太长，所以一般使用 16 进制来表示。比如简体中文字符 "木" 的 Unicode Code Point 是 U+6729, 日语字符 "き" 的 Unicode Code Point 是 U+304E

Unicode 兼容了 ASCII, 所有的 128 个 ASCII 字符在 Unicode 里有和在 ASCII 中相同的 Code Point, 比如小写字母 "a" 的 Unicode Code Point 为 U+0061

在 [Graphemica](https://graphemica.com) 上可以查到指定字符对应的 Unicode Code Point

注意: Unicode 只列出了字符对应的 Code Point, 并没有指明该使用多少个字节表示一个字符。实际上，Unicode 有多种不同的实现，最著名的是 UTF-8

#### UTF-8

UTF 是 Universal Transformation Format 的缩写

#### Wrong decoding => Garbled Text

#### We all ❤️ Emoji!

#### Fonts

#### Tools & Websites
